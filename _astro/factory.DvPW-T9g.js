class f{id;name;type;participants;started;completed;createdAt;updatedAt;constructor(t,e){this.id=e||this.generateId(),this.name=t.name,this.type=t.type,this.participants=t.participantNames.map((i,s)=>({id:this.generateId(),name:i,seed:s+1})),this.started=!1,this.completed=!1,this.createdAt=new Date,this.updatedAt=new Date}getId(){return this.id}getName(){return this.name}setName(t){this.name=t,this.touch()}getType(){return this.type}getParticipants(){return[...this.participants]}addParticipant(t){if(this.started)throw new Error("Cannot add participants after tournament has started");const e={id:this.generateId(),name:t,seed:this.participants.length+1};this.participants.push(e),this.touch()}removeParticipant(t){if(this.started)throw new Error("Cannot remove participants after tournament has started");const e=this.participants.findIndex(i=>i.id===t);if(e===-1)throw new Error(`Participant with id ${t} not found`);this.participants.splice(e,1),this.participants.forEach((i,s)=>{i.seed=s+1}),this.touch()}isStarted(){return this.started}isComplete(){return this.completed}getCreatedAt(){return this.createdAt}getUpdatedAt(){return this.updatedAt}generateId(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,t=>{const e=Math.random()*16|0;return(t==="x"?e:e&3|8).toString(16)})}touch(){this.updatedAt=new Date}getParticipantById(t){return this.participants.find(e=>e.id===t)}validateParticipants(t){if(this.participants.length<t)throw new Error(`This tournament requires at least ${t} participants`)}shuffleParticipants(){for(let t=this.participants.length-1;t>0;t--){const e=Math.floor(Math.random()*(t+1));[this.participants[t],this.participants[e]]=[this.participants[e],this.participants[t]]}this.participants.forEach((t,e)=>{t.seed=e+1})}createMatch(t,e,i){return{id:this.generateId(),status:"pending",participantIds:t,round:e,matchNumber:i}}export(){return this.touch(),this.exportState()}import(t){this.importState(t),this.touch()}}class w extends f{bracket=[];thirdPlaceMatch;options;constructor(t,e){super(t,e),this.options=t}start(){if(this.started)throw new Error("Tournament already started");this.validateParticipants(2),this.generateBracket(),this.started=!0,this.touch()}generateBracket(){const t=this.options.matchType==="multi-player",e=this.options.playersPerMatch||2;!t||e===2?this.generateHeadToHeadBracket():this.generateMultiPlayerBracket(e)}generateHeadToHeadBracket(){const t=this.participants.length,e=Math.ceil(Math.log2(t)),s=Math.pow(2,e)-t,r=(t-s)/2;this.bracket=[];for(let h=0;h<r;h++)this.bracket.push({id:this.generateId(),status:"pending",participantIds:[],matchNumber:this.bracket.length+1,round:1});let a=r,c=2;for(;a>0||c===2;){let h;c===2?h=(r+s)/2:h=a/2;for(let p=0;p<h;p++)this.bracket.push({id:this.generateId(),status:"pending",participantIds:[],matchNumber:this.bracket.length+1,round:c});if(a=h,c++,h===1)break}this.seedBracket(r,s)}generateMultiPlayerBracket(t){const e=this.participants.length;this.bracket=[];const i=[...this.participants].sort((r,a)=>(r.seed||0)-(a.seed||0));for(let r=0;r<e;r+=t){const a=i.slice(r,r+t);if(a.length>0){const c={id:this.generateId(),status:"pending",participantIds:a.map(h=>h.id),matchNumber:this.bracket.length+1,round:1};this.bracket.push(c)}}let s=2,n=this.bracket.length;for(;n>1;){const r=Math.ceil(n/t);for(let a=0;a<r;a++){const c={id:this.generateId(),status:"pending",participantIds:[],matchNumber:this.bracket.length+1,round:s};this.bracket.push(c)}n=r,s++}}seedBracket(t,e){const i=[...this.participants].sort((a,c)=>(a.seed||0)-(c.seed||0)),s=i.slice(0,e),n=i.slice(e);for(let a=0;a<t;a++){const c=n[a],h=n[n.length-1-a];c&&h&&(this.bracket[a].participantIds=[c.id,h.id])}const r=t;s.forEach((a,c)=>{const h=r+Math.floor(c/2);this.bracket[h]&&this.bracket[h].participantIds.push(a.id)})}getCurrentMatches(){if(!this.started)return[];const t=this.options.matchType==="multi-player";this.options.playersPerMatch;const e=2,i=this.bracket.filter(s=>s.participantIds.length>=e&&s.status!=="completed");return this.thirdPlaceMatch&&this.thirdPlaceMatch.status!=="completed"&&this.thirdPlaceMatch.participantIds.length>=e&&i.push(this.thirdPlaceMatch),i}recordMatchResult(t,e){if(!this.started)throw new Error("Tournament not started");const i=this.bracket.findIndex(r=>r.id===t);let s;if(i>=0)s=this.bracket[i];else if(this.thirdPlaceMatch&&this.thirdPlaceMatch.id===t)s=this.thirdPlaceMatch;else throw new Error(`Match with id ${t} not found`);if(s.status==="completed")throw new Error("Match already completed");if(this.options.matchType==="multi-player"&&s.participantIds.length>2){if(!e.rankings||e.rankings.length===0)throw new Error("Multi-player matches require rankings for all participants");if(e.rankings.length!==s.participantIds.length)throw new Error("All participants must be ranked");if(s.participantIds.length<2)throw new Error("Match must have at least 2 participants");const r=e.rankings.find(a=>a.position===1);if(!r)throw new Error("Rankings must include a 1st place finisher");e.winnerId=r.participantId}else{if(!e.winnerId)throw this.options.tieBreakers?new Error("Tie breakers are enabled - match cannot end in a tie"):new Error("Single elimination requires a winner for each match");if(s.participantIds.length!==2)throw new Error("Match does not have 2 participants");if(!s.participantIds.includes(e.winnerId))throw new Error("Winner ID does not match a participant in this match")}s.result=e,s.status="completed",i>=0&&this.advanceWinner(i,e.winnerId),this.checkCompletion(),this.touch()}advanceWinner(t,e){const i=this.bracket.length,s=this.options.matchType==="multi-player",n=this.options.playersPerMatch||2;!s||n===2?this.advanceWinnerHeadToHead(t,e,i):this.advanceWinnerMultiPlayer(t,e,i,n)}advanceWinnerHeadToHead(t,e,i){const s=i-Math.floor((i-t)/2);if(t===i-1){if(this.options.thirdPlaceMatch&&!this.thirdPlaceMatch){const n=this.bracket[t];if(n.participantIds.find(a=>a!==e)){const a=this.bracket.filter(c=>c.round===n.round-1&&c.status==="completed");if(a.length===2){const c=a.map(h=>{const p=h.result?.winnerId;return h.participantIds.find(d=>d!==p)}).filter(Boolean);c.length===2&&(this.thirdPlaceMatch={id:this.generateId(),status:"pending",participantIds:c,matchNumber:i+1,round:n.round})}}}return}if(s<i){const n=this.bracket[s];n.participantIds.includes(e)||n.participantIds.push(e)}}advanceWinnerMultiPlayer(t,e,i,s){const n=this.bracket[t],r=n.round||1,a=this.bracket.filter(d=>d.round===r+1);if(a.length===0){if(this.options.thirdPlaceMatch&&!this.thirdPlaceMatch&&n.result?.rankings){const d=n.result.rankings.filter(l=>l.position===2||l.position===3).sort((l,u)=>l.position-u.position);d.length>=2&&(this.thirdPlaceMatch={id:this.generateId(),status:"pending",participantIds:d.map(l=>l.participantId),matchNumber:i+1,round:r})}return}this.bracket.filter(d=>d.round===r).length;const c=this.bracket.filter(d=>d.round===r).findIndex(d=>d.id===n.id),h=Math.floor(c/s),p=a[h];p&&!p.participantIds.includes(e)&&p.participantIds.push(e)}checkCompletion(){if(this.bracket[this.bracket.length-1].status!=="completed"){this.completed=!1;return}this.options.thirdPlaceMatch&&this.thirdPlaceMatch?this.completed=this.thirdPlaceMatch.status==="completed":this.completed=!0}getStandings(){const t=[];return this.participants.forEach(e=>{const s=[...this.bracket,...this.thirdPlaceMatch?[this.thirdPlaceMatch]:[]].filter(p=>p.participantIds.includes(e.id)).filter(p=>p.status==="completed"),n=s.filter(p=>p.result?.winnerId===e.id).length,r=s.filter(p=>p.result?.winnerId&&p.result.winnerId!==e.id).length,a=r>0;let c=0;const h=this.bracket[this.bracket.length-1];h.status==="completed"&&(h.result?.winnerId===e.id?c=1:h.participantIds.includes(e.id)&&(c=2)),this.thirdPlaceMatch?.status==="completed"&&(this.thirdPlaceMatch.result?.winnerId===e.id?c=3:this.thirdPlaceMatch.participantIds.includes(e.id)&&c===0&&(c=4)),t.push({participantId:e.id,participantName:e.name,rank:c,wins:n,losses:r,ties:0,matchesPlayed:s.length,isEliminated:a})}),t.sort((e,i)=>e.rank&&i.rank?e.rank-i.rank:e.rank?-1:i.rank?1:e.wins!==i.wins?i.wins-e.wins:e.participantName.localeCompare(i.participantName)),t}exportState(){return{version:"1.0.0",id:this.id,name:this.name,type:"single-elimination",createdAt:this.createdAt.toISOString(),updatedAt:this.updatedAt.toISOString(),started:this.started,completed:this.completed,participants:this.participants,options:this.options,bracket:this.bracket,thirdPlaceMatch:this.thirdPlaceMatch}}importState(t){this.id=t.id,this.name=t.name,this.started=t.started,this.completed=t.completed,this.participants=t.participants,this.bracket=t.bracket,this.thirdPlaceMatch=t.thirdPlaceMatch,this.createdAt=new Date(t.createdAt),this.updatedAt=new Date(t.updatedAt)}getBracket(){return[...this.bracket]}getThirdPlaceMatch(){return this.thirdPlaceMatch}}class P extends f{winnersBracket=[];losersBracket=[];grandFinal;grandFinalReset;options;participantLosses=new Map;constructor(t,e){super(t,e),this.options=t}start(){if(this.started)throw new Error("Tournament already started");this.validateParticipants(2),this.participants.forEach(t=>{this.participantLosses.set(t.id,0)}),this.generateBrackets(),this.started=!0,this.touch()}generateBrackets(){const t=this.participants.length;let e=[...this.participants],i=[];if(this.options.splitStart&&t>=4){const s=Math.floor(t/2);i=e.splice(s),i.forEach(n=>{this.participantLosses.set(n.id,1)})}this.generateWinnersBracket(e),i.length>0&&this.generateInitialLosersBracket(i)}generateWinnersBracket(t){const e=t.length,i=Math.ceil(Math.log2(e)),s=Math.pow(2,i)-1;for(let d=0;d<s;d++)this.winnersBracket.push({id:this.generateId(),status:"pending",participantIds:[],matchNumber:d+1});const n=Math.ceil(e/2),r=Math.pow(2,i)-e,a=[...t].sort((d,l)=>(d.seed||0)-(l.seed||0)),c=a.slice(0,r),h=a.slice(r);for(let d=0;d<h.length/2;d++){const l=h[d],u=h[h.length-1-d];l&&u&&(this.winnersBracket[d].participantIds=[l.id,u.id])}const p=n;c.forEach((d,l)=>{const u=p+Math.floor(l/2);this.winnersBracket[u]&&this.winnersBracket[u].participantIds.push(d.id)}),this.assignRoundsToMatches(this.winnersBracket)}generateInitialLosersBracket(t){for(let e=0;e<Math.floor(t.length/2);e++){const i=this.createMatch([t[e*2].id,t[e*2+1]?.id].filter(Boolean),1);this.losersBracket.push(i)}if(t.length%2===1){const e=t[t.length-1],i=this.createMatch([e.id],1);i.status="completed",i.result={winnerId:e.id},this.losersBracket.push(i)}}assignRoundsToMatches(t){const e=t.length;let i=0,s=1;for(;i<e;){const n=Math.pow(2,Math.ceil(Math.log2(e+1))-s);for(let r=0;r<n&&i<e;r++)t[i].round=s,i++;s++}}getCurrentMatches(){if(!this.started)return[];const t=[];return t.push(...this.winnersBracket.filter(e=>e.participantIds.length===2&&e.status!=="completed")),t.push(...this.losersBracket.filter(e=>e.participantIds.length===2&&e.status!=="completed")),this.grandFinal&&this.grandFinal.status!=="completed"&&this.grandFinal.participantIds.length===2&&t.push(this.grandFinal),this.grandFinalReset&&this.grandFinalReset.status!=="completed"&&this.grandFinalReset.participantIds.length===2&&t.push(this.grandFinalReset),t}recordMatchResult(t,e){if(!this.started)throw new Error("Tournament not started");if(!e.winnerId)throw this.options.tieBreakers?new Error("Tie breakers are enabled - match cannot end in a tie"):new Error("Double elimination requires a winner for each match");let i,s=!1,n=!1,r=!1,a=!1;const c=this.winnersBracket.findIndex(l=>l.id===t);if(c>=0)i=this.winnersBracket[c],s=!0;else{const l=this.losersBracket.findIndex(u=>u.id===t);l>=0?(i=this.losersBracket[l],n=!0):this.grandFinal?.id===t?(i=this.grandFinal,r=!0):this.grandFinalReset?.id===t&&(i=this.grandFinalReset,a=!0)}if(!i)throw new Error(`Match with id ${t} not found`);if(i.status==="completed")throw new Error("Match already completed");i.result=e,i.status="completed";const h=e.winnerId,p=i.participantIds.find(l=>l!==h),d=this.participantLosses.get(p)||0;this.participantLosses.set(p,d+1),s?this.handleWinnersBracketResult(c,h,p):n?this.handleLosersBracketResult(h,p):r?this.handleGrandFinalResult(h,p):a&&(this.completed=!0),this.touch()}handleWinnersBracketResult(t,e,i){const s=this.winnersBracket.length;if(t===s-1)this.createGrandFinalIfNeeded(),this.grandFinal&&!this.grandFinal.participantIds.includes(e)&&this.grandFinal.participantIds.push(e),this.addToLosersBracketFinal(i);else{const n=s-Math.floor((s-t)/2);if(n<s){const r=this.winnersBracket[n];r.participantIds.includes(e)||r.participantIds.push(e)}this.addToLosersBracket(i)}}handleLosersBracketResult(t,e){this.losersBracket.filter(s=>s.status!=="completed").length===0?(this.createGrandFinalIfNeeded(),this.grandFinal&&!this.grandFinal.participantIds.includes(t)&&this.grandFinal.participantIds.push(t)):this.addToLosersBracket(t)}handleGrandFinalResult(t,e){(this.participantLosses.get(t)||0)===1?this.grandFinalReset={id:this.generateId(),status:"pending",participantIds:[t,e],matchNumber:(this.grandFinal?.matchNumber||0)+1}:this.completed=!0}addToLosersBracket(t){const e=this.losersBracket.find(i=>i.participantIds.length<2&&i.status==="pending");if(e)e.participantIds.push(t);else{const i=this.createMatch([t]);this.losersBracket.push(i)}}addToLosersBracketFinal(t){const e=this.losersBracket[this.losersBracket.length-1];if(e&&e.status==="pending"&&e.participantIds.length<2)e.participantIds.push(t);else{const i=this.createMatch([t]);this.losersBracket.push(i)}}createGrandFinalIfNeeded(){this.grandFinal||(this.grandFinal={id:this.generateId(),status:"pending",participantIds:[],matchNumber:this.winnersBracket.length+this.losersBracket.length+1})}getStandings(){const t=[];return this.participants.forEach(e=>{const n=[...this.winnersBracket,...this.losersBracket,...this.grandFinal?[this.grandFinal]:[],...this.grandFinalReset?[this.grandFinalReset]:[]].filter(p=>p.participantIds.includes(e.id)).filter(p=>p.status==="completed"),r=n.filter(p=>p.result?.winnerId===e.id).length,a=this.participantLosses.get(e.id)||0,c=a>=2;let h=0;this.completed&&(this.grandFinalReset?.status==="completed"?this.grandFinalReset.result?.winnerId===e.id?h=1:this.grandFinalReset.participantIds.includes(e.id)&&(h=2):this.grandFinal?.status==="completed"&&(this.grandFinal.result?.winnerId===e.id?h=1:this.grandFinal.participantIds.includes(e.id)&&(h=2))),t.push({participantId:e.id,participantName:e.name,rank:h,wins:r,losses:a,ties:0,matchesPlayed:n.length,isEliminated:c})}),t.sort((e,i)=>e.rank&&i.rank?e.rank-i.rank:e.rank?-1:i.rank?1:e.losses!==i.losses?e.losses-i.losses:e.wins!==i.wins?i.wins-e.wins:e.participantName.localeCompare(i.participantName)),t}exportState(){return{version:"1.0.0",id:this.id,name:this.name,type:"double-elimination",createdAt:this.createdAt.toISOString(),updatedAt:this.updatedAt.toISOString(),started:this.started,completed:this.completed,participants:this.participants,options:this.options,winnersBracket:this.winnersBracket,losersBracket:this.losersBracket,grandFinal:this.grandFinal,grandFinalReset:this.grandFinalReset}}importState(t){this.id=t.id,this.name=t.name,this.started=t.started,this.completed=t.completed,this.participants=t.participants,this.winnersBracket=t.winnersBracket,this.losersBracket=t.losersBracket,this.grandFinal=t.grandFinal,this.grandFinalReset=t.grandFinalReset,this.createdAt=new Date(t.createdAt),this.updatedAt=new Date(t.updatedAt),this.participantLosses=new Map,this.participants.forEach(e=>{let i=0;[...this.winnersBracket,...this.losersBracket,...this.grandFinal?[this.grandFinal]:[],...this.grandFinalReset?[this.grandFinalReset]:[]].forEach(n=>{n.status==="completed"&&n.result?.winnerId&&n.participantIds.includes(e.id)&&n.result.winnerId!==e.id&&i++}),this.participantLosses.set(e.id,i)})}getWinnersBracket(){return[...this.winnersBracket]}getLosersBracket(){return[...this.losersBracket]}getGrandFinal(){return this.grandFinal}getGrandFinalReset(){return this.grandFinalReset}}const R={f1:{name:"Formula 1",type:"f1",description:"Official F1 scoring system (top 10 score points)",bestFor:"Competitive racing with large gaps between placements",points:[25,18,15,12,10,8,6,4,2,1],maxPlayers:10},"mario-kart":{name:"Mario Kart",type:"mario-kart",description:"Mario Kart 8 Deluxe scoring (all placements score)",bestFor:"Casual racing where everyone earns points",points:[15,12,10,9,8,7,6,5,4,3,2,1],maxPlayers:12},linear:{name:"Linear Descending",type:"linear",description:"Equal point gaps between placements (N, N-1, N-2, ..., 1)",bestFor:"Equal point gaps between all placements",points:[]},"winner-takes-most":{name:"Winner Takes Most",type:"winner-takes-most",description:"Winning is worth twice as much as 2nd place",bestFor:"Emphasizing winning over consistent placement",points:[]},custom:{name:"Custom",type:"custom",description:"Define your own point distribution",bestFor:"Specific tournament requirements",points:[]}};function b(o,t){const e=R[o.type];switch(o.type){case"f1":case"mario-kart":{const i=e.points;return t<=i.length?i.slice(0,t):[...i,...Array(t-i.length).fill(0)]}case"linear":return Array.from({length:t},(i,s)=>t-s);case"winner-takes-most":{if(t===1)return[t];const i=Array.from({length:t},(s,n)=>t-n);return i[0]=t*2,i}case"custom":{if(!o.customPoints||o.customPoints.length===0)throw new Error("Custom points system requires customPoints array");return t<=o.customPoints.length?o.customPoints.slice(0,t):[...o.customPoints,...Array(t-o.customPoints.length).fill(0)]}default:throw new Error(`Unknown points system type: ${o.type}`)}}function g(o,t,e){const i=b(o,e),s=t-1;return s<0||s>=i.length?0:i[s]}function S(o,t,e){return e==="winner-only"?o===1?3:0:o===1?3:o===2?2:o===3?1:0}function E(o){if(!o.type)throw new Error("Points system type is required");if(o.type==="custom"){if(!o.customPoints||o.customPoints.length===0)throw new Error("Custom points system requires customPoints array with at least one value");if(o.customPoints.some(t=>t<0))throw new Error("Points cannot be negative");for(let t=1;t<o.customPoints.length;t++)if(o.customPoints[t]>o.customPoints[t-1]){console.warn("Custom points are not in descending order - this may lead to unexpected results");break}}}function k(o){return{type:"mario-kart"}}class M extends f{matches=[];currentRound=0;options;constructor(t,e){super(t,e),this.options=t,t.matchType==="multi-player"&&!t.pointsSystem&&(this.options.pointsSystem=k())}start(){if(this.started)throw new Error("Tournament already started");this.validateParticipants(2),this.generateMatches(),this.started=!0,this.currentRound=1,this.touch()}generateMatches(){this.matches=[];const t=this.options.matchType==="multi-player",e=this.options.playersPerMatch||2;!t||e===2?this.generateHeadToHeadMatches():this.generateMultiPlayerMatches(),this.matches.forEach((i,s)=>{i.matchNumber=s+1})}generateHeadToHeadMatches(){for(let t=1;t<=this.options.rounds;t++)for(let e=0;e<this.participants.length;e++)for(let i=e+1;i<this.participants.length;i++){const s=this.createMatch([this.participants[e].id,this.participants[i].id],t);this.matches.push(s)}}generateMultiPlayerMatches(){const t=this.options.playersPerMatch||4;for(let e=1;e<=this.options.rounds;e++){const i=this.rotateParticipants(e-1);for(let s=0;s<i.length;s+=t){const n=i.slice(s,s+t);if(n.length>=2){const r=this.createMatch(n.map(a=>a.id),e);this.matches.push(r)}}}}rotateParticipants(t){const e=this.participants.length,i=t*Math.floor(e/2)%e;return[...this.participants.slice(i),...this.participants.slice(0,i)]}getCurrentMatches(){return this.started?this.matches.filter(t=>t.status!=="completed"&&t.round<=this.currentRound):[]}recordMatchResult(t,e){if(!this.started)throw new Error("Tournament not started");const i=this.matches.find(n=>n.id===t);if(!i)throw new Error(`Match with id ${t} not found`);if(i.status==="completed")throw new Error("Match already completed");if(this.options.matchType==="multi-player"&&i.participantIds.length>2){if(!e.rankings||e.rankings.length===0)throw new Error("Multi-player matches require rankings for all participants");if(e.rankings.length!==i.participantIds.length)throw new Error("All participants must be ranked");this.options.rankingMethod==="points"&&this.options.pointsSystem&&(e.score={},e.rankings.forEach(n=>{const r=g(this.options.pointsSystem,n.position,i.participantIds.length);e.score[n.participantId]=r}))}else{if(this.options.rankingMethod==="points"&&!e.score)throw new Error("Score is required when ranking by points");if(this.options.rankingMethod==="wins"&&!e.winnerId&&!e.isTie)throw new Error("Winner or tie must be specified when ranking by wins")}i.result=e,i.status="completed",this.checkRoundCompletion(),this.checkCompletion(),this.touch()}checkRoundCompletion(){if(this.currentRound>=this.options.rounds)return;this.matches.filter(i=>i.round===this.currentRound).every(i=>i.status==="completed")&&this.currentRound++}checkCompletion(){this.completed=this.matches.every(t=>t.status==="completed")}getStandings(){const t=[],e=this.options.matchType==="multi-player";return this.participants.forEach(i=>{const n=this.matches.filter(p=>p.participantIds.includes(i.id)).filter(p=>p.status==="completed");let r=0,a=0,c=0,h=0;n.forEach(p=>{const d=p.result;if(e&&p.participantIds.length>2){if(d.rankings){const l=d.rankings.find(u=>u.participantId===i.id);l&&(l.position===1?r++:l.position===p.participantIds.length&&a++)}d.score&&(h+=d.score[i.id]||0)}else if(this.options.rankingMethod==="wins")d.isTie?c++:d.winnerId===i.id?r++:a++;else if(this.options.rankingMethod==="points"&&d.score){const l=d.score[i.id]||0;h+=l;const u=p.participantIds.find(m=>m!==i.id);if(u){const m=d.score[u]||0;l>m?r++:l<m?a++:c++}}}),t.push({participantId:i.id,participantName:i.name,rank:0,wins:r,losses:a,ties:c,points:this.options.rankingMethod==="points"||e?h:void 0,matchesPlayed:n.length})}),this.options.rankingMethod==="wins"&&!e?t.sort((i,s)=>i.wins!==s.wins?s.wins-i.wins:i.losses!==s.losses?i.losses-s.losses:i.participantName.localeCompare(s.participantName)):t.sort((i,s)=>{const n=i.points||0,r=s.points||0;return n!==r?r-n:i.wins!==s.wins?s.wins-i.wins:i.participantName.localeCompare(s.participantName)}),t.forEach((i,s)=>{i.rank=s+1}),t}exportState(){return{version:"1.0.0",id:this.id,name:this.name,type:"round-robin",createdAt:this.createdAt.toISOString(),updatedAt:this.updatedAt.toISOString(),started:this.started,completed:this.completed,participants:this.participants,options:this.options,matches:this.matches,currentRound:this.currentRound}}importState(t){this.id=t.id,this.name=t.name,this.started=t.started,this.completed=t.completed,this.participants=t.participants,this.matches=t.matches,this.currentRound=t.currentRound,this.createdAt=new Date(t.createdAt),this.updatedAt=new Date(t.updatedAt)}getMatchesByRound(){const t=new Map;return this.matches.forEach(e=>{const i=e.round||1;t.has(i)||t.set(i,[]),t.get(i).push(e)}),t}getCurrentRound(){return this.currentRound}getTotalRounds(){return this.options.rounds}}class y extends f{rounds=[];currentRound=0;participantScores=new Map;options;numberOfRounds;constructor(t,e){super(t,e),this.options=t,t.matchType==="multi-player"&&(t.pointsSystem||(this.options.pointsSystem=k()),t.matchPointsFormula||(this.options.matchPointsFormula="proportional")),this.numberOfRounds=t.numberOfRounds||Math.ceil(Math.log2(t.participantNames.length))}start(){if(this.started)throw new Error("Tournament already started");this.validateParticipants(2),this.participants.forEach(t=>{this.participantScores.set(t.id,{participantId:t.id,matchPoints:0,gamePoints:0,opponentIds:[],matchesPlayed:0})}),this.generateNextRound(),this.started=!0,this.currentRound=1,this.touch()}generateNextRound(){if(this.currentRound>=this.numberOfRounds)return;const t=[],e=this.options.matchType==="multi-player",i=this.options.playersPerMatch||2;!e||i===2?this.generateHeadToHeadPairings(t):this.generateMultiPlayerPairings(t,i);const s=this.rounds.flat().length;t.forEach((n,r)=>{n.matchNumber=s+r+1}),this.rounds.push(t)}generateHeadToHeadPairings(t){const e=[...this.participants].map(s=>({participant:s,score:this.participantScores.get(s.id)})).sort((s,n)=>s.score.matchPoints!==n.score.matchPoints?n.score.matchPoints-s.score.matchPoints:n.score.gamePoints-s.score.gamePoints),i=new Set(e.map(s=>s.participant.id));for(;i.size>1;){const s=e.find(c=>i.has(c.participant.id));if(!s)break;const n=s.participant,r=s.score;i.delete(n.id);let a=null;for(const c of e)if(i.has(c.participant.id)&&!r.opponentIds.includes(c.participant.id)){a=c.participant;break}if(!a){for(const c of e)if(i.has(c.participant.id)){a=c.participant;break}}if(a){i.delete(a.id);const c=this.createMatch([n.id,a.id],this.rounds.length+1);t.push(c)}}if(i.size===1){const s=i.values().next().value,n=this.createMatch([s],this.rounds.length+1);n.status="completed",n.result={winnerId:s,score:{[s]:this.options.pointsPerBye}};const r=this.participantScores.get(s);r.matchPoints+=this.options.pointsPerBye,r.matchesPlayed++,t.push(n)}}generateMultiPlayerPairings(t,e){const i=[...this.participants].map(n=>({participant:n,score:this.participantScores.get(n.id)})).sort((n,r)=>n.score.matchPoints!==r.score.matchPoints?r.score.matchPoints-n.score.matchPoints:r.score.gamePoints-n.score.gamePoints),s=new Set(i.map(n=>n.participant.id));for(;s.size>=2;){const n=[];for(const r of i){if(n.length>=e)break;s.has(r.participant.id)&&(!n.every(c=>this.participantScores.get(r.participant.id).opponentIds.includes(c))||s.size<=e)&&(n.push(r.participant.id),s.delete(r.participant.id))}if(n.length>=2){const r=this.createMatch(n,this.rounds.length+1);t.push(r)}else break}if(s.size===1){const n=s.values().next().value,r=this.createMatch([n],this.rounds.length+1);r.status="completed",r.result={winnerId:n,score:{[n]:this.options.pointsPerBye},rankings:[{participantId:n,position:1}]};const a=this.participantScores.get(n);a.matchPoints+=this.options.pointsPerBye,a.matchesPlayed++,t.push(r)}}getCurrentMatches(){return!this.started||this.currentRound===0?[]:(this.rounds[this.currentRound-1]||[]).filter(e=>e.status!=="completed")}recordMatchResult(t,e){if(!this.started)throw new Error("Tournament not started");let i;for(const n of this.rounds)if(i=n.find(r=>r.id===t),i)break;if(!i)throw new Error(`Match with id ${t} not found`);if(i.status==="completed")throw new Error("Match already completed");if(this.options.matchType==="multi-player"&&i.participantIds.length>2){if(!e.rankings||e.rankings.length===0)throw new Error("Multi-player Swiss matches require rankings for all participants");if(e.rankings.length!==i.participantIds.length)throw new Error("All participants must be ranked");this.options.pointsSystem&&(e.score={},e.rankings.forEach(r=>{const a=g(this.options.pointsSystem,r.position,i.participantIds.length);e.score[r.participantId]=a}));const n=this.options.matchPointsFormula||"proportional";e.rankings.forEach(r=>{const a=this.participantScores.get(r.participantId),c=S(r.position,i.participantIds.length,n);a.matchPoints+=c,e.score&&e.score[r.participantId]&&(a.gamePoints+=e.score[r.participantId]*this.options.pointsPerGameWin),i.participantIds.forEach(h=>{h!==r.participantId&&!a.opponentIds.includes(h)&&a.opponentIds.push(h)}),a.matchesPlayed++})}else{if(!e.score)throw new Error("Swiss system requires game scores for each match");const[n,r]=i.participantIds,a=e.score[n]||0,c=e.score[r]||0;a>c?(e.winnerId=n,e.loserId=r):c>a?(e.winnerId=r,e.loserId=n):e.isTie=!0;const h=this.participantScores.get(n),p=this.participantScores.get(r);e.isTie?(h.matchPoints+=this.options.pointsPerMatchTie,p.matchPoints+=this.options.pointsPerMatchTie):e.winnerId===n?h.matchPoints+=this.options.pointsPerMatchWin:p.matchPoints+=this.options.pointsPerMatchWin,h.gamePoints+=a*this.options.pointsPerGameWin,p.gamePoints+=c*this.options.pointsPerGameWin,h.opponentIds.push(r),p.opponentIds.push(n),h.matchesPlayed++,p.matchesPlayed++}i.result=e,i.status="completed",this.checkRoundCompletion(),this.touch()}checkRoundCompletion(){if(this.currentRound===0||this.currentRound>this.rounds.length)return;this.rounds[this.currentRound-1].every(i=>i.status==="completed")&&(this.currentRound>=this.numberOfRounds?this.completed=!0:(this.currentRound++,this.generateNextRound()))}getStandings(){const t=[];return this.participants.forEach(e=>{const i=this.participantScores.get(e.id);let s=0,n=0,r=0,a=0,c=0;for(const h of this.rounds)h.filter(d=>d.participantIds.includes(e.id)).forEach(d=>{if(d.status==="completed"&&d.result&&(d.result.isTie?r++:d.result.winnerId===e.id?s++:d.participantIds.length>1&&n++,d.result.score)){const l=d.result.score[e.id]||0;a+=l,d.participantIds.forEach(u=>{u!==e.id&&d.result.score&&(c+=d.result.score[u]||0)})}});t.push({participantId:e.id,participantName:e.name,rank:0,wins:s,losses:n,ties:r,points:i.matchPoints,gamesWon:a,gamesLost:c,matchesPlayed:i.matchesPlayed})}),t.sort((e,i)=>e.points!==i.points?(i.points||0)-(e.points||0):e.gamesWon!==i.gamesWon?(i.gamesWon||0)-(e.gamesWon||0):e.gamesLost!==i.gamesLost?(e.gamesLost||0)-(i.gamesLost||0):e.participantName.localeCompare(i.participantName)),t.forEach((e,i)=>{e.rank=i+1}),t}exportState(){const t={};return this.participantScores.forEach((e,i)=>{t[i]=e}),{version:"1.0.0",id:this.id,name:this.name,type:"swiss",createdAt:this.createdAt.toISOString(),updatedAt:this.updatedAt.toISOString(),started:this.started,completed:this.completed,participants:this.participants,options:this.options,rounds:this.rounds,currentRound:this.currentRound,participantScores:t}}importState(t){this.id=t.id,this.name=t.name,this.started=t.started,this.completed=t.completed,this.participants=t.participants,this.rounds=t.rounds,this.currentRound=t.currentRound,this.createdAt=new Date(t.createdAt),this.updatedAt=new Date(t.updatedAt),this.participantScores=new Map,Object.entries(t.participantScores).forEach(([e,i])=>{this.participantScores.set(e,i)}),this.numberOfRounds=t.options.numberOfRounds||Math.ceil(Math.log2(this.participants.length))}getRounds(){return this.rounds.map(t=>[...t])}getCurrentRound(){return this.currentRound}getNumberOfRounds(){return this.numberOfRounds}}class I extends f{rounds=[];currentRound=0;eliminatedParticipants=new Set;options;constructor(t,e){if(super(t,e),this.options=t,t.participantsPerMatch<2)throw new Error("Participants per match must be at least 2");if(t.advancementRule==="top-n"){if(!t.advancementCount||t.advancementCount<1)throw new Error("advancementCount must be at least 1 when using top-n advancement");if(t.advancementCount>=t.participantsPerMatch)throw new Error("advancementCount must be less than participantsPerMatch")}}start(){if(this.started)throw new Error("Tournament already started");this.validateParticipants(this.options.participantsPerMatch),this.generateRound(this.participants.map(t=>t.id)),this.started=!0,this.currentRound=1,this.touch()}generateRound(t){const e=[],i=this.options.participantsPerMatch;for(let s=0;s<t.length;s+=i){const n=t.slice(s,s+i);if(n.length>=2){const r=this.createMatch(n,this.rounds.length+1,e.length+1);e.push(r)}else if(n.length===1){const r=this.createMatch(n,this.rounds.length+1,e.length+1);r.status="completed",r.result={rankings:[{participantId:n[0],position:1}]},e.push(r)}}this.rounds.push(e)}getCurrentMatches(){return!this.started||this.currentRound===0?[]:(this.rounds[this.currentRound-1]||[]).filter(e=>e.status!=="completed")}recordMatchResult(t,e){if(!this.started)throw new Error("Tournament not started");let i;for(const a of this.rounds)if(i=a.find(c=>c.id===t),i)break;if(!i)throw new Error(`Match with id ${t} not found`);if(i.status==="completed")throw new Error("Match already completed");if(!e.rankings||e.rankings.length===0)throw new Error("Free For All requires rankings for all participants");if(e.rankings.length!==i.participantIds.length)throw new Error("All participants must be ranked");const s=e.rankings.map(a=>a.position).sort((a,c)=>a-c);for(let a=0;a<s.length;a++)if(s[a]!==a+1)throw new Error("Rankings must be consecutive starting from 1");this.options.pointsSystem&&(e.score={},e.rankings.forEach(a=>{const c=g(this.options.pointsSystem,a.position,i.participantIds.length);e.score[a.participantId]=c})),i.result=e,i.status="completed";const r=(this.options.advancementRule||"winner-only")==="top-n"&&this.options.advancementCount||1;e.rankings.forEach(a=>{a.position>r&&this.eliminatedParticipants.add(a.participantId)}),this.checkRoundCompletion(),this.touch()}checkRoundCompletion(){if(this.currentRound===0||this.currentRound>this.rounds.length)return;const t=this.rounds[this.currentRound-1];if(!t.every(a=>a.status==="completed"))return;const i=[],n=(this.options.advancementRule||"winner-only")==="top-n"&&this.options.advancementCount||1;if(t.forEach(a=>{if(a.result?.rankings){const c=a.result.rankings.filter(h=>h.position<=n).map(h=>h.participantId);i.push(...c)}}),i.length<2){this.completed=!0;return}if(i.length<=this.options.participantsPerMatch&&i.length>=2){this.rounds.length===this.currentRound?(this.currentRound++,this.generateRound(i)):this.completed=!0;return}i.length>=2?(this.currentRound++,this.generateRound(i)):this.completed=!0}getStandings(){const t=[];this.participants.forEach(i=>{let s=0,n=0,r=0;this.rounds.forEach((h,p)=>{h.filter(l=>l.participantIds.includes(i.id)).forEach(l=>{if(l.status==="completed"&&l.result?.rankings){r++;const u=l.result.rankings.find(m=>m.participantId===i.id);u&&(u.position===1?s++:n++)}})});const a=this.eliminatedParticipants.has(i.id);let c=0;if(this.completed&&s===r&&r>0){const h=this.rounds.length-1;this.rounds[h]?.[0]?.result?.rankings?.[0]?.participantId===i.id&&(c=1)}t.push({participantId:i.id,participantName:i.name,rank:c,wins:s,losses:n,ties:0,matchesPlayed:r,isEliminated:a})}),t.sort((i,s)=>i.rank&&s.rank?i.rank-s.rank:i.rank?-1:s.rank?1:i.wins!==s.wins?s.wins-i.wins:i.matchesPlayed!==s.matchesPlayed?s.matchesPlayed-i.matchesPlayed:i.participantName.localeCompare(s.participantName));let e=1;return t.forEach((i,s)=>{i.rank===0&&(s>0&&i.wins===t[s-1].wins&&i.matchesPlayed===t[s-1].matchesPlayed?i.rank=t[s-1].rank:i.rank=e),e=i.rank+1}),t}exportState(){return{version:"1.0.0",id:this.id,name:this.name,type:"free-for-all",createdAt:this.createdAt.toISOString(),updatedAt:this.updatedAt.toISOString(),started:this.started,completed:this.completed,participants:this.participants,options:this.options,rounds:this.rounds,currentRound:this.currentRound,eliminatedParticipants:Array.from(this.eliminatedParticipants)}}importState(t){this.id=t.id,this.name=t.name,this.started=t.started,this.completed=t.completed,this.participants=t.participants,this.rounds=t.rounds,this.currentRound=t.currentRound,this.eliminatedParticipants=new Set(t.eliminatedParticipants),this.createdAt=new Date(t.createdAt),this.updatedAt=new Date(t.updatedAt)}getRounds(){return this.rounds.map(t=>[...t])}getCurrentRound(){return this.currentRound}getEliminatedParticipants(){return Array.from(this.eliminatedParticipants)}}function v(o){switch(o.type){case"single-elimination":return new w(o);case"double-elimination":return new P(o);case"round-robin":return new M(o);case"swiss":return new y(o);case"free-for-all":return new I(o);default:const t=o;throw new Error(`Unknown tournament type: ${t.type}`)}}function B(o){let t;switch(o.type){case"single-elimination":{t=new w(o.options,o.id),t.import(o);break}case"double-elimination":{t=new P(o.options,o.id),t.import(o);break}case"round-robin":{t=new M(o.options,o.id),t.import(o);break}case"swiss":{t=new y(o.options,o.id),t.import(o);break}case"free-for-all":{t=new I(o.options,o.id),t.import(o);break}default:{const e=o;throw new Error(`Unknown tournament type: ${e.type}`)}}return t}function F(o){const t={name:"New Tournament",participantNames:[],matchType:"head-to-head",playersPerMatch:2};switch(o){case"single-elimination":return{...t,type:o,thirdPlaceMatch:!1,tieBreakers:!0,advancementRule:"winner-only"};case"double-elimination":return{...t,type:o,splitStart:!1,tieBreakers:!0};case"round-robin":return{...t,type:o,rankingMethod:"wins",rounds:1,pointsSystem:void 0};case"swiss":return{...t,type:o,pointsPerMatchWin:3,pointsPerMatchTie:1,pointsPerGameWin:1,pointsPerGameTie:0,pointsPerBye:3,pointsSystem:void 0,matchPointsFormula:"proportional"};case"free-for-all":return{...t,type:o,participantsPerMatch:4,advancementRule:"winner-only",pointsSystem:void 0};default:{const e=o;throw new Error(`Unknown tournament type: ${e}`)}}}function x(o){const t=[];(!o.name||o.name.trim()==="")&&t.push("Tournament name is required"),(!o.participantNames||o.participantNames.length<2)&&t.push("At least 2 participants are required"),o.participantNames&&new Set(o.participantNames.map(n=>n.trim().toLowerCase())).size!==o.participantNames.length&&t.push("Participant names must be unique");const e=o.matchType,i=o.playersPerMatch;if(e==="multi-player"){(!i||i<2)&&t.push("Players per match must be at least 2 for multi-player matches"),i&&o.participantNames&&i>o.participantNames.length&&t.push("Players per match cannot exceed total participant count");const s=o.pointsSystem;if(s)try{E(s)}catch(n){t.push(n.message)}}if(o.type==="free-for-all"){const s=o;s.participantsPerMatch&&(s.participantsPerMatch<2||s.participantsPerMatch>(o.participantNames?.length||0))&&t.push(`Participants per match must be between 2 and ${o.participantNames?.length||0}`),s.advancementRule==="top-n"&&((!s.advancementCount||s.advancementCount<1)&&t.push("Advancement count must be at least 1 when using top-n advancement"),s.advancementCount&&s.participantsPerMatch&&s.advancementCount>=s.participantsPerMatch&&t.push("Advancement count must be less than participants per match"))}if(o.type==="swiss"){const s=o;s.pointsPerMatchWin!==void 0&&s.pointsPerMatchWin<0&&t.push("Points per match win must be non-negative"),s.pointsPerMatchTie!==void 0&&s.pointsPerMatchTie<0&&t.push("Points per match tie must be non-negative"),s.pointsPerGameWin!==void 0&&s.pointsPerGameWin<0&&t.push("Points per game win must be non-negative"),s.pointsPerGameTie!==void 0&&s.pointsPerGameTie<0&&t.push("Points per game tie must be non-negative"),s.pointsPerBye!==void 0&&s.pointsPerBye<0&&t.push("Points per bye must be non-negative")}if(o.type==="round-robin"){const s=o;s.rounds&&(s.rounds<1||s.rounds>3)&&t.push("Rounds must be between 1 and 3"),e==="multi-player"&&i&&i>2&&o.rankingMethod==="points"&&!o.pointsSystem&&t.push("Points system is required for multi-player round robin with points ranking")}return t}export{g as a,v as c,F as g,B as r,x as v};
