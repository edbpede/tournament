class m{id;name;type;participants;started;completed;createdAt;updatedAt;constructor(t,e){this.id=e||this.generateId(),this.name=t.name,this.type=t.type,this.participants=t.participantNames.map((i,n)=>({id:this.generateId(),name:i,seed:n+1})),this.started=!1,this.completed=!1,this.createdAt=new Date,this.updatedAt=new Date}getId(){return this.id}getName(){return this.name}setName(t){this.name=t,this.touch()}getType(){return this.type}getParticipants(){return[...this.participants]}addParticipant(t){if(this.started)throw new Error("Cannot add participants after tournament has started");const e={id:this.generateId(),name:t,seed:this.participants.length+1};this.participants.push(e),this.touch()}removeParticipant(t){if(this.started)throw new Error("Cannot remove participants after tournament has started");const e=this.participants.findIndex(i=>i.id===t);if(e===-1)throw new Error(`Participant with id ${t} not found`);this.participants.splice(e,1),this.participants.forEach((i,n)=>{i.seed=n+1}),this.touch()}isStarted(){return this.started}isComplete(){return this.completed}getCreatedAt(){return this.createdAt}getUpdatedAt(){return this.updatedAt}generateId(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,t=>{const e=Math.random()*16|0;return(t==="x"?e:e&3|8).toString(16)})}touch(){this.updatedAt=new Date}getParticipantById(t){return this.participants.find(e=>e.id===t)}validateParticipants(t){if(this.participants.length<t)throw new Error(`This tournament requires at least ${t} participants`)}shuffleParticipants(){for(let t=this.participants.length-1;t>0;t--){const e=Math.floor(Math.random()*(t+1));[this.participants[t],this.participants[e]]=[this.participants[e],this.participants[t]]}this.participants.forEach((t,e)=>{t.seed=e+1})}createMatch(t,e,i){return{id:this.generateId(),status:"pending",participantIds:t,round:e,matchNumber:i}}export(){return this.touch(),this.exportState()}import(t){this.importState(t),this.touch()}}class f extends m{bracket=[];thirdPlaceMatch;options;constructor(t,e){super(t,e),this.options=t}start(){if(this.started)throw new Error("Tournament already started");this.validateParticipants(2),this.generateBracket(),this.started=!0,this.touch()}generateBracket(){const t=this.participants.length,e=Math.ceil(Math.log2(t)),i=Math.ceil(t/2),n=Math.pow(2,e)-t,s=Math.pow(2,e)-1;this.bracket=[];for(let r=0;r<s;r++)this.bracket.push({id:this.generateId(),status:"pending",participantIds:[],matchNumber:r+1});this.seedBracket(i,n),this.assignRounds()}seedBracket(t,e){const i=[...this.participants].sort((h,c)=>(h.seed||0)-(c.seed||0)),n=i.slice(0,e),s=i.slice(e);for(let h=0;h<t;h++)if(h<s.length/2){const c=s[h],a=s[s.length-1-h];c&&a&&(this.bracket[h].participantIds=[c.id,a.id])}const r=t;n.forEach((h,c)=>{const a=r+Math.floor(c/2);this.bracket[a]&&this.bracket[a].participantIds.push(h.id)})}assignRounds(){const t=this.bracket.length;let e=0,i=1;for(;e<t;){const n=Math.pow(2,Math.ceil(Math.log2(t+1))-i);for(let s=0;s<n&&e<t;s++)this.bracket[e].round=i,e++;i++}}getCurrentMatches(){if(!this.started)return[];const t=this.bracket.filter(e=>e.participantIds.length===2&&e.status!=="completed");return this.thirdPlaceMatch&&this.thirdPlaceMatch.status!=="completed"&&this.thirdPlaceMatch.participantIds.length===2&&t.push(this.thirdPlaceMatch),t}recordMatchResult(t,e){if(!this.started)throw new Error("Tournament not started");if(!e.winnerId)throw this.options.tieBreakers?new Error("Tie breakers are enabled - match cannot end in a tie"):new Error("Single elimination requires a winner for each match");const i=this.bracket.findIndex(s=>s.id===t);let n;if(i>=0)n=this.bracket[i];else if(this.thirdPlaceMatch&&this.thirdPlaceMatch.id===t)n=this.thirdPlaceMatch;else throw new Error(`Match with id ${t} not found`);if(n.participantIds.length!==2)throw new Error("Match does not have 2 participants");if(n.status==="completed")throw new Error("Match already completed");if(!n.participantIds.includes(e.winnerId))throw new Error("Winner ID does not match a participant in this match");n.result=e,n.status="completed",i>=0&&this.advanceWinner(i,e.winnerId),this.checkCompletion(),this.touch()}advanceWinner(t,e){const i=this.bracket.length,n=i-Math.floor((i-t)/2);if(t===i-1){if(this.options.thirdPlaceMatch&&!this.thirdPlaceMatch){const s=this.bracket[t];if(s.participantIds.find(h=>h!==e)){const h=this.bracket.filter(c=>c.round===s.round-1&&c.status==="completed");if(h.length===2){const c=h.map(a=>{const p=a.result?.winnerId;return a.participantIds.find(d=>d!==p)}).filter(Boolean);c.length===2&&(this.thirdPlaceMatch={id:this.generateId(),status:"pending",participantIds:c,matchNumber:i+1,round:s.round})}}}return}if(n<i){const s=this.bracket[n];s.participantIds.includes(e)||s.participantIds.push(e)}}checkCompletion(){if(this.bracket[this.bracket.length-1].status!=="completed"){this.completed=!1;return}this.options.thirdPlaceMatch&&this.thirdPlaceMatch?this.completed=this.thirdPlaceMatch.status==="completed":this.completed=!0}getStandings(){const t=[];return this.participants.forEach(e=>{const n=[...this.bracket,...this.thirdPlaceMatch?[this.thirdPlaceMatch]:[]].filter(p=>p.participantIds.includes(e.id)).filter(p=>p.status==="completed"),s=n.filter(p=>p.result?.winnerId===e.id).length,r=n.filter(p=>p.result?.winnerId&&p.result.winnerId!==e.id).length,h=r>0;let c=0;const a=this.bracket[this.bracket.length-1];a.status==="completed"&&(a.result?.winnerId===e.id?c=1:a.participantIds.includes(e.id)&&(c=2)),this.thirdPlaceMatch?.status==="completed"&&(this.thirdPlaceMatch.result?.winnerId===e.id?c=3:this.thirdPlaceMatch.participantIds.includes(e.id)&&c===0&&(c=4)),t.push({participantId:e.id,participantName:e.name,rank:c,wins:s,losses:r,ties:0,matchesPlayed:n.length,isEliminated:h})}),t.sort((e,i)=>e.rank&&i.rank?e.rank-i.rank:e.rank?-1:i.rank?1:e.wins!==i.wins?i.wins-e.wins:e.participantName.localeCompare(i.participantName)),t}exportState(){return{version:"1.0.0",id:this.id,name:this.name,type:"single-elimination",createdAt:this.createdAt.toISOString(),updatedAt:this.updatedAt.toISOString(),started:this.started,completed:this.completed,participants:this.participants,options:this.options,bracket:this.bracket,thirdPlaceMatch:this.thirdPlaceMatch}}importState(t){this.id=t.id,this.name=t.name,this.started=t.started,this.completed=t.completed,this.participants=t.participants,this.bracket=t.bracket,this.thirdPlaceMatch=t.thirdPlaceMatch,this.createdAt=new Date(t.createdAt),this.updatedAt=new Date(t.updatedAt)}getBracket(){return[...this.bracket]}getThirdPlaceMatch(){return this.thirdPlaceMatch}}class g extends m{winnersBracket=[];losersBracket=[];grandFinal;grandFinalReset;options;participantLosses=new Map;constructor(t,e){super(t,e),this.options=t}start(){if(this.started)throw new Error("Tournament already started");this.validateParticipants(2),this.participants.forEach(t=>{this.participantLosses.set(t.id,0)}),this.generateBrackets(),this.started=!0,this.touch()}generateBrackets(){const t=this.participants.length;let e=[...this.participants],i=[];if(this.options.splitStart&&t>=4){const n=Math.floor(t/2);i=e.splice(n),i.forEach(s=>{this.participantLosses.set(s.id,1)})}this.generateWinnersBracket(e),i.length>0&&this.generateInitialLosersBracket(i)}generateWinnersBracket(t){const e=t.length,i=Math.ceil(Math.log2(e)),n=Math.pow(2,i)-1;for(let d=0;d<n;d++)this.winnersBracket.push({id:this.generateId(),status:"pending",participantIds:[],matchNumber:d+1});const s=Math.ceil(e/2),r=Math.pow(2,i)-e,h=[...t].sort((d,l)=>(d.seed||0)-(l.seed||0)),c=h.slice(0,r),a=h.slice(r);for(let d=0;d<a.length/2;d++){const l=a[d],u=a[a.length-1-d];l&&u&&(this.winnersBracket[d].participantIds=[l.id,u.id])}const p=s;c.forEach((d,l)=>{const u=p+Math.floor(l/2);this.winnersBracket[u]&&this.winnersBracket[u].participantIds.push(d.id)}),this.assignRoundsToMatches(this.winnersBracket)}generateInitialLosersBracket(t){for(let e=0;e<Math.floor(t.length/2);e++){const i=this.createMatch([t[e*2].id,t[e*2+1]?.id].filter(Boolean),1);this.losersBracket.push(i)}if(t.length%2===1){const e=t[t.length-1],i=this.createMatch([e.id],1);i.status="completed",i.result={winnerId:e.id},this.losersBracket.push(i)}}assignRoundsToMatches(t){const e=t.length;let i=0,n=1;for(;i<e;){const s=Math.pow(2,Math.ceil(Math.log2(e+1))-n);for(let r=0;r<s&&i<e;r++)t[i].round=n,i++;n++}}getCurrentMatches(){if(!this.started)return[];const t=[];return t.push(...this.winnersBracket.filter(e=>e.participantIds.length===2&&e.status!=="completed")),t.push(...this.losersBracket.filter(e=>e.participantIds.length===2&&e.status!=="completed")),this.grandFinal&&this.grandFinal.status!=="completed"&&this.grandFinal.participantIds.length===2&&t.push(this.grandFinal),this.grandFinalReset&&this.grandFinalReset.status!=="completed"&&this.grandFinalReset.participantIds.length===2&&t.push(this.grandFinalReset),t}recordMatchResult(t,e){if(!this.started)throw new Error("Tournament not started");if(!e.winnerId)throw this.options.tieBreakers?new Error("Tie breakers are enabled - match cannot end in a tie"):new Error("Double elimination requires a winner for each match");let i,n=!1,s=!1,r=!1,h=!1;const c=this.winnersBracket.findIndex(l=>l.id===t);if(c>=0)i=this.winnersBracket[c],n=!0;else{const l=this.losersBracket.findIndex(u=>u.id===t);l>=0?(i=this.losersBracket[l],s=!0):this.grandFinal?.id===t?(i=this.grandFinal,r=!0):this.grandFinalReset?.id===t&&(i=this.grandFinalReset,h=!0)}if(!i)throw new Error(`Match with id ${t} not found`);if(i.status==="completed")throw new Error("Match already completed");i.result=e,i.status="completed";const a=e.winnerId,p=i.participantIds.find(l=>l!==a),d=this.participantLosses.get(p)||0;this.participantLosses.set(p,d+1),n?this.handleWinnersBracketResult(c,a,p):s?this.handleLosersBracketResult(a,p):r?this.handleGrandFinalResult(a,p):h&&(this.completed=!0),this.touch()}handleWinnersBracketResult(t,e,i){const n=this.winnersBracket.length;if(t===n-1)this.createGrandFinalIfNeeded(),this.grandFinal&&!this.grandFinal.participantIds.includes(e)&&this.grandFinal.participantIds.push(e),this.addToLosersBracketFinal(i);else{const s=n-Math.floor((n-t)/2);if(s<n){const r=this.winnersBracket[s];r.participantIds.includes(e)||r.participantIds.push(e)}this.addToLosersBracket(i)}}handleLosersBracketResult(t,e){this.losersBracket.filter(n=>n.status!=="completed").length===0?(this.createGrandFinalIfNeeded(),this.grandFinal&&!this.grandFinal.participantIds.includes(t)&&this.grandFinal.participantIds.push(t)):this.addToLosersBracket(t)}handleGrandFinalResult(t,e){(this.participantLosses.get(t)||0)===1?this.grandFinalReset={id:this.generateId(),status:"pending",participantIds:[t,e],matchNumber:(this.grandFinal?.matchNumber||0)+1}:this.completed=!0}addToLosersBracket(t){const e=this.losersBracket.find(i=>i.participantIds.length<2&&i.status==="pending");if(e)e.participantIds.push(t);else{const i=this.createMatch([t]);this.losersBracket.push(i)}}addToLosersBracketFinal(t){const e=this.losersBracket[this.losersBracket.length-1];if(e&&e.status==="pending"&&e.participantIds.length<2)e.participantIds.push(t);else{const i=this.createMatch([t]);this.losersBracket.push(i)}}createGrandFinalIfNeeded(){this.grandFinal||(this.grandFinal={id:this.generateId(),status:"pending",participantIds:[],matchNumber:this.winnersBracket.length+this.losersBracket.length+1})}getStandings(){const t=[];return this.participants.forEach(e=>{const s=[...this.winnersBracket,...this.losersBracket,...this.grandFinal?[this.grandFinal]:[],...this.grandFinalReset?[this.grandFinalReset]:[]].filter(p=>p.participantIds.includes(e.id)).filter(p=>p.status==="completed"),r=s.filter(p=>p.result?.winnerId===e.id).length,h=this.participantLosses.get(e.id)||0,c=h>=2;let a=0;this.completed&&(this.grandFinalReset?.status==="completed"?this.grandFinalReset.result?.winnerId===e.id?a=1:this.grandFinalReset.participantIds.includes(e.id)&&(a=2):this.grandFinal?.status==="completed"&&(this.grandFinal.result?.winnerId===e.id?a=1:this.grandFinal.participantIds.includes(e.id)&&(a=2))),t.push({participantId:e.id,participantName:e.name,rank:a,wins:r,losses:h,ties:0,matchesPlayed:s.length,isEliminated:c})}),t.sort((e,i)=>e.rank&&i.rank?e.rank-i.rank:e.rank?-1:i.rank?1:e.losses!==i.losses?e.losses-i.losses:e.wins!==i.wins?i.wins-e.wins:e.participantName.localeCompare(i.participantName)),t}exportState(){return{version:"1.0.0",id:this.id,name:this.name,type:"double-elimination",createdAt:this.createdAt.toISOString(),updatedAt:this.updatedAt.toISOString(),started:this.started,completed:this.completed,participants:this.participants,options:this.options,winnersBracket:this.winnersBracket,losersBracket:this.losersBracket,grandFinal:this.grandFinal,grandFinalReset:this.grandFinalReset}}importState(t){this.id=t.id,this.name=t.name,this.started=t.started,this.completed=t.completed,this.participants=t.participants,this.winnersBracket=t.winnersBracket,this.losersBracket=t.losersBracket,this.grandFinal=t.grandFinal,this.grandFinalReset=t.grandFinalReset,this.createdAt=new Date(t.createdAt),this.updatedAt=new Date(t.updatedAt),this.participantLosses=new Map,this.participants.forEach(e=>{let i=0;[...this.winnersBracket,...this.losersBracket,...this.grandFinal?[this.grandFinal]:[],...this.grandFinalReset?[this.grandFinalReset]:[]].forEach(s=>{s.status==="completed"&&s.result?.winnerId&&s.participantIds.includes(e.id)&&s.result.winnerId!==e.id&&i++}),this.participantLosses.set(e.id,i)})}getWinnersBracket(){return[...this.winnersBracket]}getLosersBracket(){return[...this.losersBracket]}getGrandFinal(){return this.grandFinal}getGrandFinalReset(){return this.grandFinalReset}}class w extends m{matches=[];currentRound=0;options;constructor(t,e){super(t,e),this.options=t}start(){if(this.started)throw new Error("Tournament already started");this.validateParticipants(2),this.generateMatches(),this.started=!0,this.currentRound=1,this.touch()}generateMatches(){this.matches=[];for(let t=1;t<=this.options.rounds;t++)for(let e=0;e<this.participants.length;e++)for(let i=e+1;i<this.participants.length;i++){const n=this.createMatch([this.participants[e].id,this.participants[i].id],t);this.matches.push(n)}this.matches.forEach((t,e)=>{t.matchNumber=e+1})}getCurrentMatches(){return this.started?this.matches.filter(t=>t.status!=="completed"&&t.round<=this.currentRound):[]}recordMatchResult(t,e){if(!this.started)throw new Error("Tournament not started");const i=this.matches.find(n=>n.id===t);if(!i)throw new Error(`Match with id ${t} not found`);if(i.status==="completed")throw new Error("Match already completed");if(this.options.rankingMethod==="points"&&!e.score)throw new Error("Score is required when ranking by points");if(this.options.rankingMethod==="wins"&&!e.winnerId&&!e.isTie)throw new Error("Winner or tie must be specified when ranking by wins");i.result=e,i.status="completed",this.checkRoundCompletion(),this.checkCompletion(),this.touch()}checkRoundCompletion(){if(this.currentRound>=this.options.rounds)return;this.matches.filter(i=>i.round===this.currentRound).every(i=>i.status==="completed")&&this.currentRound++}checkCompletion(){this.completed=this.matches.every(t=>t.status==="completed")}getStandings(){const t=[];return this.participants.forEach(e=>{const n=this.matches.filter(a=>a.participantIds.includes(e.id)).filter(a=>a.status==="completed");let s=0,r=0,h=0,c=0;n.forEach(a=>{const p=a.result;if(this.options.rankingMethod==="wins")p.isTie?h++:p.winnerId===e.id?s++:r++;else if(this.options.rankingMethod==="points"&&p.score){const d=p.score[e.id]||0;c+=d;const l=a.participantIds.find(u=>u!==e.id);if(l){const u=p.score[l]||0;d>u?s++:d<u?r++:h++}}}),t.push({participantId:e.id,participantName:e.name,rank:0,wins:s,losses:r,ties:h,points:this.options.rankingMethod==="points"?c:void 0,matchesPlayed:n.length})}),this.options.rankingMethod==="wins"?t.sort((e,i)=>e.wins!==i.wins?i.wins-e.wins:e.losses!==i.losses?e.losses-i.losses:e.participantName.localeCompare(i.participantName)):t.sort((e,i)=>{const n=e.points||0,s=i.points||0;return n!==s?s-n:e.wins!==i.wins?i.wins-e.wins:e.participantName.localeCompare(i.participantName)}),t.forEach((e,i)=>{e.rank=i+1}),t}exportState(){return{version:"1.0.0",id:this.id,name:this.name,type:"round-robin",createdAt:this.createdAt.toISOString(),updatedAt:this.updatedAt.toISOString(),started:this.started,completed:this.completed,participants:this.participants,options:this.options,matches:this.matches,currentRound:this.currentRound}}importState(t){this.id=t.id,this.name=t.name,this.started=t.started,this.completed=t.completed,this.participants=t.participants,this.matches=t.matches,this.currentRound=t.currentRound,this.createdAt=new Date(t.createdAt),this.updatedAt=new Date(t.updatedAt)}getMatchesByRound(){const t=new Map;return this.matches.forEach(e=>{const i=e.round||1;t.has(i)||t.set(i,[]),t.get(i).push(e)}),t}getCurrentRound(){return this.currentRound}getTotalRounds(){return this.options.rounds}}class M extends m{rounds=[];currentRound=0;participantScores=new Map;options;numberOfRounds;constructor(t,e){super(t,e),this.options=t,this.numberOfRounds=t.numberOfRounds||Math.ceil(Math.log2(t.participantNames.length))}start(){if(this.started)throw new Error("Tournament already started");this.validateParticipants(2),this.participants.forEach(t=>{this.participantScores.set(t.id,{participantId:t.id,matchPoints:0,gamePoints:0,opponentIds:[],matchesPlayed:0})}),this.generateNextRound(),this.started=!0,this.currentRound=1,this.touch()}generateNextRound(){if(this.currentRound>=this.numberOfRounds)return;const t=[],e=[...this.participants].map(s=>({participant:s,score:this.participantScores.get(s.id)})).sort((s,r)=>s.score.matchPoints!==r.score.matchPoints?r.score.matchPoints-s.score.matchPoints:r.score.gamePoints-s.score.gamePoints),i=new Set(e.map(s=>s.participant.id));for(;i.size>1;){const s=e.find(a=>i.has(a.participant.id));if(!s)break;const r=s.participant,h=s.score;i.delete(r.id);let c=null;for(const a of e)if(i.has(a.participant.id)&&!h.opponentIds.includes(a.participant.id)){c=a.participant;break}if(!c){for(const a of e)if(i.has(a.participant.id)){c=a.participant;break}}if(c){i.delete(c.id);const a=this.createMatch([r.id,c.id],this.rounds.length+1);t.push(a)}}if(i.size===1){const s=i.values().next().value,r=this.createMatch([s],this.rounds.length+1);r.status="completed",r.result={winnerId:s,score:{[s]:this.options.pointsPerBye}};const h=this.participantScores.get(s);h.matchPoints+=this.options.pointsPerBye,h.matchesPlayed++,t.push(r)}const n=this.rounds.flat().length;t.forEach((s,r)=>{s.matchNumber=n+r+1}),this.rounds.push(t)}getCurrentMatches(){return!this.started||this.currentRound===0?[]:(this.rounds[this.currentRound-1]||[]).filter(e=>e.status!=="completed")}recordMatchResult(t,e){if(!this.started)throw new Error("Tournament not started");let i;for(const p of this.rounds)if(i=p.find(d=>d.id===t),i)break;if(!i)throw new Error(`Match with id ${t} not found`);if(i.status==="completed")throw new Error("Match already completed");if(!e.score)throw new Error("Swiss system requires game scores for each match");const[n,s]=i.participantIds,r=e.score[n]||0,h=e.score[s]||0;r>h?(e.winnerId=n,e.loserId=s):h>r?(e.winnerId=s,e.loserId=n):e.isTie=!0;const c=this.participantScores.get(n),a=this.participantScores.get(s);e.isTie?(c.matchPoints+=this.options.pointsPerMatchTie,a.matchPoints+=this.options.pointsPerMatchTie):e.winnerId===n?c.matchPoints+=this.options.pointsPerMatchWin:a.matchPoints+=this.options.pointsPerMatchWin,c.gamePoints+=r*this.options.pointsPerGameWin,a.gamePoints+=h*this.options.pointsPerGameWin,c.opponentIds.push(s),a.opponentIds.push(n),c.matchesPlayed++,a.matchesPlayed++,i.result=e,i.status="completed",this.checkRoundCompletion(),this.touch()}checkRoundCompletion(){if(this.currentRound===0||this.currentRound>this.rounds.length)return;this.rounds[this.currentRound-1].every(i=>i.status==="completed")&&(this.currentRound>=this.numberOfRounds?this.completed=!0:(this.currentRound++,this.generateNextRound()))}getStandings(){const t=[];return this.participants.forEach(e=>{const i=this.participantScores.get(e.id);let n=0,s=0,r=0,h=0,c=0;for(const a of this.rounds)a.filter(d=>d.participantIds.includes(e.id)).forEach(d=>{if(d.status==="completed"&&d.result&&(d.result.isTie?r++:d.result.winnerId===e.id?n++:d.participantIds.length>1&&s++,d.result.score)){const l=d.result.score[e.id]||0;h+=l,d.participantIds.forEach(u=>{u!==e.id&&d.result.score&&(c+=d.result.score[u]||0)})}});t.push({participantId:e.id,participantName:e.name,rank:0,wins:n,losses:s,ties:r,points:i.matchPoints,gamesWon:h,gamesLost:c,matchesPlayed:i.matchesPlayed})}),t.sort((e,i)=>e.points!==i.points?(i.points||0)-(e.points||0):e.gamesWon!==i.gamesWon?(i.gamesWon||0)-(e.gamesWon||0):e.gamesLost!==i.gamesLost?(e.gamesLost||0)-(i.gamesLost||0):e.participantName.localeCompare(i.participantName)),t.forEach((e,i)=>{e.rank=i+1}),t}exportState(){const t={};return this.participantScores.forEach((e,i)=>{t[i]=e}),{version:"1.0.0",id:this.id,name:this.name,type:"swiss",createdAt:this.createdAt.toISOString(),updatedAt:this.updatedAt.toISOString(),started:this.started,completed:this.completed,participants:this.participants,options:this.options,rounds:this.rounds,currentRound:this.currentRound,participantScores:t}}importState(t){this.id=t.id,this.name=t.name,this.started=t.started,this.completed=t.completed,this.participants=t.participants,this.rounds=t.rounds,this.currentRound=t.currentRound,this.createdAt=new Date(t.createdAt),this.updatedAt=new Date(t.updatedAt),this.participantScores=new Map,Object.entries(t.participantScores).forEach(([e,i])=>{this.participantScores.set(e,i)}),this.numberOfRounds=t.options.numberOfRounds||Math.ceil(Math.log2(this.participants.length))}getRounds(){return this.rounds.map(t=>[...t])}getCurrentRound(){return this.currentRound}getNumberOfRounds(){return this.numberOfRounds}}class k extends m{rounds=[];currentRound=0;eliminatedParticipants=new Set;options;constructor(t,e){if(super(t,e),this.options=t,t.participantsPerMatch<2)throw new Error("Participants per match must be at least 2")}start(){if(this.started)throw new Error("Tournament already started");this.validateParticipants(this.options.participantsPerMatch),this.generateRound(this.participants.map(t=>t.id)),this.started=!0,this.currentRound=1,this.touch()}generateRound(t){const e=[],i=this.options.participantsPerMatch;for(let n=0;n<t.length;n+=i){const s=t.slice(n,n+i);if(s.length>=2){const r=this.createMatch(s,this.rounds.length+1,e.length+1);e.push(r)}else if(s.length===1){const r=this.createMatch(s,this.rounds.length+1,e.length+1);r.status="completed",r.result={rankings:[{participantId:s[0],position:1}]},e.push(r)}}this.rounds.push(e)}getCurrentMatches(){return!this.started||this.currentRound===0?[]:(this.rounds[this.currentRound-1]||[]).filter(e=>e.status!=="completed")}recordMatchResult(t,e){if(!this.started)throw new Error("Tournament not started");let i;for(const s of this.rounds)if(i=s.find(r=>r.id===t),i)break;if(!i)throw new Error(`Match with id ${t} not found`);if(i.status==="completed")throw new Error("Match already completed");if(!e.rankings||e.rankings.length===0)throw new Error("Free For All requires rankings for all participants");if(e.rankings.length!==i.participantIds.length)throw new Error("All participants must be ranked");const n=e.rankings.map(s=>s.position).sort((s,r)=>s-r);for(let s=0;s<n.length;s++)if(n[s]!==s+1)throw new Error("Rankings must be consecutive starting from 1");i.result=e,i.status="completed",e.rankings.forEach(s=>{s.position>1&&this.eliminatedParticipants.add(s.participantId)}),this.checkRoundCompletion(),this.touch()}checkRoundCompletion(){if(this.currentRound===0||this.currentRound>this.rounds.length)return;const t=this.rounds[this.currentRound-1];if(!t.every(n=>n.status==="completed"))return;const i=[];if(t.forEach(n=>{if(n.result?.rankings){const s=n.result.rankings.find(r=>r.position===1);s&&i.push(s.participantId)}}),i.length===1){this.completed=!0;return}i.length>=2?(this.currentRound++,this.generateRound(i)):this.completed=!0}getStandings(){const t=[];this.participants.forEach(i=>{let n=0,s=0,r=0;this.rounds.forEach((a,p)=>{a.filter(l=>l.participantIds.includes(i.id)).forEach(l=>{if(l.status==="completed"&&l.result?.rankings){r++;const u=l.result.rankings.find(P=>P.participantId===i.id);u&&(u.position===1?n++:s++)}})});const h=this.eliminatedParticipants.has(i.id);let c=0;if(this.completed&&n===r&&r>0){const a=this.rounds.length-1;this.rounds[a]?.[0]?.result?.rankings?.[0]?.participantId===i.id&&(c=1)}t.push({participantId:i.id,participantName:i.name,rank:c,wins:n,losses:s,ties:0,matchesPlayed:r,isEliminated:h})}),t.sort((i,n)=>i.rank&&n.rank?i.rank-n.rank:i.rank?-1:n.rank?1:i.wins!==n.wins?n.wins-i.wins:i.matchesPlayed!==n.matchesPlayed?n.matchesPlayed-i.matchesPlayed:i.participantName.localeCompare(n.participantName));let e=1;return t.forEach((i,n)=>{i.rank===0&&(n>0&&i.wins===t[n-1].wins&&i.matchesPlayed===t[n-1].matchesPlayed?i.rank=t[n-1].rank:i.rank=e),e=i.rank+1}),t}exportState(){return{version:"1.0.0",id:this.id,name:this.name,type:"free-for-all",createdAt:this.createdAt.toISOString(),updatedAt:this.updatedAt.toISOString(),started:this.started,completed:this.completed,participants:this.participants,options:this.options,rounds:this.rounds,currentRound:this.currentRound,eliminatedParticipants:Array.from(this.eliminatedParticipants)}}importState(t){this.id=t.id,this.name=t.name,this.started=t.started,this.completed=t.completed,this.participants=t.participants,this.rounds=t.rounds,this.currentRound=t.currentRound,this.eliminatedParticipants=new Set(t.eliminatedParticipants),this.createdAt=new Date(t.createdAt),this.updatedAt=new Date(t.updatedAt)}getRounds(){return this.rounds.map(t=>[...t])}getCurrentRound(){return this.currentRound}getEliminatedParticipants(){return Array.from(this.eliminatedParticipants)}}function R(o){switch(o.type){case"single-elimination":return new f(o);case"double-elimination":return new g(o);case"round-robin":return new w(o);case"swiss":return new M(o);case"free-for-all":return new k(o);default:const t=o;throw new Error(`Unknown tournament type: ${t.type}`)}}function I(o){let t;switch(o.type){case"single-elimination":{t=new f(o.options,o.id),t.import(o);break}case"double-elimination":{t=new g(o.options,o.id),t.import(o);break}case"round-robin":{t=new w(o.options,o.id),t.import(o);break}case"swiss":{t=new M(o.options,o.id),t.import(o);break}case"free-for-all":{t=new k(o.options,o.id),t.import(o);break}default:{const e=o;throw new Error(`Unknown tournament type: ${e.type}`)}}return t}function B(o){const t={name:"New Tournament",participantNames:[]};switch(o){case"single-elimination":return{...t,type:o,thirdPlaceMatch:!1,tieBreakers:!0};case"double-elimination":return{...t,type:o,splitStart:!1,tieBreakers:!0};case"round-robin":return{...t,type:o,rankingMethod:"wins",rounds:1};case"swiss":return{...t,type:o,pointsPerMatchWin:3,pointsPerMatchTie:1,pointsPerGameWin:1,pointsPerGameTie:0,pointsPerBye:3};case"free-for-all":return{...t,type:o,participantsPerMatch:4};default:{const e=o;throw new Error(`Unknown tournament type: ${e}`)}}}function E(o){const t=[];if((!o.name||o.name.trim()==="")&&t.push("Tournament name is required"),(!o.participantNames||o.participantNames.length<2)&&t.push("At least 2 participants are required"),o.participantNames&&new Set(o.participantNames.map(i=>i.trim().toLowerCase())).size!==o.participantNames.length&&t.push("Participant names must be unique"),o.type==="free-for-all"){const e=o;e.participantsPerMatch&&(e.participantsPerMatch<2||e.participantsPerMatch>(o.participantNames?.length||0))&&t.push(`Participants per match must be between 2 and ${o.participantNames?.length||0}`)}if(o.type==="swiss"){const e=o;e.pointsPerMatchWin!==void 0&&e.pointsPerMatchWin<0&&t.push("Points per match win must be non-negative"),e.pointsPerMatchTie!==void 0&&e.pointsPerMatchTie<0&&t.push("Points per match tie must be non-negative"),e.pointsPerGameWin!==void 0&&e.pointsPerGameWin<0&&t.push("Points per game win must be non-negative"),e.pointsPerGameTie!==void 0&&e.pointsPerGameTie<0&&t.push("Points per game tie must be non-negative"),e.pointsPerBye!==void 0&&e.pointsPerBye<0&&t.push("Points per bye must be non-negative")}if(o.type==="round-robin"){const e=o;e.rounds&&(e.rounds<1||e.rounds>3)&&t.push("Rounds must be between 1 and 3")}return t}export{R as c,B as g,I as r,E as v};
